<!doctype html> <html lang=en > <meta charset=UTF-8 > <meta name=viewport  content="width=device-width, initial-scale=1"> <link rel=stylesheet  href="/ral/libs/highlight/styles/github.min.css"> <link rel=stylesheet  href="/ral/css/franklin.css"> <link rel=stylesheet  href="/ral/css/pure.css"> <link rel=stylesheet  href="/ral/css/side-menu.css"> <style> .franklin-content{padding-left:10%;} @media (min-width: 940px) { .franklin-content {width: 900px; margin-left: 0px; padding-left: 80px;} .header{width: 900px; margin-left: 0px; padding-left: 80px;} } </style> <link rel=icon  href="/ral/assets/favicon.png"> <title>The Adapter</title> <div id=layout > <a href="#menu" id=menuLink  class=menu-link ><span></span></a> <div id=menu > <div class=pure-menu > <a class=pure-menu-heading  href="#">RAL</a> <ul class=pure-menu-list > <li class="pure-menu-item "><a href="/ral/" class=pure-menu-link >Introduction</a> <li class="pure-menu-item "><a href="/ral/register_block/" class=pure-menu-link >Register Blocks</a> <li class="pure-menu-item pure-menu-selected"><a href="/ral/adapter/" class=pure-menu-link >Adapter</a> <li class="pure-menu-item "><a href="/ral/agent/" class=pure-menu-link >The Agent</a> <li class="pure-menu-item "><a href="/ral/predictor/" class=pure-menu-link >Predictor</a> <li class="pure-menu-item "><a href="/ral/env/" class=pure-menu-link >The Env</a> <li class="pure-menu-item "><a href="/ral/breath/" class=pure-menu-link >Take a breath</a> <li class="pure-menu-item "><a href="/ral/reg_sequence/" class=pure-menu-link >Reg Sequence</a> <li class="pure-menu-item "><a href="/ral/test_file/" class=pure-menu-link >The Test</a> <li class="pure-menu-item "><a href="/ral/results/" class=pure-menu-link >Results</a> <li class="pure-menu-item "><a href="/ral/source_code/" class=pure-menu-link >Source Code</a> </ul> </div> </div> <div id=main > <div class=header > <h1>The Adapter</h1> <h2>Hands-on to implement a simple UVM ambient with RAL</h2> </div> <div class=franklin-content > <h1 id=the_adapter ><a href="#the_adapter" class=header-anchor >The Adapter</a></h1> <div class=franklin-toc ><ol><li><a href="#overview">Overview</a><li><a href="#writting_an_adapter">Writting an adapter</a><ol><li><a href="#reg2bus">reg2bus</a><li><a href="#bus2reg">bus2reg</a></ol></ol></div> <h2 id=overview ><a href="#overview" class=header-anchor >Overview</a></h2> <p>Okay, now we have the registers modeled using the <code>uvm_reg</code> and <code>uvm_reg_block</code>. However, our UVM ambient uses transactions to communicate between components. The UVM ports transport transactions, and the register models are not transactions. So, we need a way to easily convert the registers to transactions and vice versa, and this is the main function of an adapter.</p> <h2 id=writting_an_adapter ><a href="#writting_an_adapter" class=header-anchor >Writting an adapter</a></h2> <p>Basically, an adapter will have two functions:</p> <ul> <li><p><code>uvm_sequence_item reg2bus&#40;const ref uvm_reg_bus_op rw&#41;</code></p> <li><p><code>void bus2reg&#40;uvm_sequence_item bus_item, ref uvm_reg_bus_op rw&#41;</code></p> </ul> <blockquote> <p>Just to remember, the <code>ref</code> means that the value is passed by reference, and not by copy</p> </blockquote> <h3 id=reg2bus ><a href="#reg2bus" class=header-anchor >reg2bus</a></h3> <p>The reg2bus will convert a <strong>RAL transaction</strong> to an <strong>Interface transaction</strong>. It receives as argument an <code>uvm_reg_bus_op</code>. This is a struct with the following fields:</p> <ul> <li><p>kind &#40;read or write&#41;</p> <li><p>address &#40;Bus address&#41;</p> <li><p>data &#40;Data to write&#41;</p> <li><p>n&#95;bits &#40;Number of bits of <code>uvm_reg_item::value</code> transferred by this transaction&#41;</p> <li><p>byte&#95;en &#40;Enables for the byte lanes on the bus&#41;. I will confess that I didn&#39;t undestand this, but we won&#39;t use in this Hands&#39;on</p> <li><p>status &#40;Result of transaction: <code>UVM_IS_OK</code>, <code>UVM_HAS_X</code>, <code>UVM_NOT_OK</code>&#41;</p> </ul> <p>So, let&#39;s code this function:</p> <pre><code class="verilog hljs"><span class=hljs-keyword >function</span> uvm_sequence_item reg2bus(<span class=hljs-keyword >const</span> <span class=hljs-keyword >ref</span> uvm_reg_bus_op rw);
	cthulhu_transaction tx;    
	tx = cthulhu_transaction::type_id::create(<span class=hljs-string >&quot;tx&quot;</span>);
	
	tx<span class=hljs-variable >.write_en</span> = (rw<span class=hljs-variable >.kind</span> == UVM_WRITE);
	tx<span class=hljs-variable >.addr</span>  = rw<span class=hljs-variable >.addr</span>;
	<span class=hljs-keyword >if</span> (tx<span class=hljs-variable >.write_en</span>)  tx<span class=hljs-variable >.data_w</span> = rw<span class=hljs-variable >.data</span>;
	<span class=hljs-keyword >if</span> (!tx<span class=hljs-variable >.write_en</span>) tx<span class=hljs-variable >.data_r</span> = rw<span class=hljs-variable >.data</span>;

	<span class=hljs-keyword >return</span> tx;
<span class=hljs-keyword >endfunction</span> : reg2bus</code></pre> <blockquote> <p>When a register is read/written, the <code>uvm_reg_map</code> calls the <code>uvm_sequence_base::start_item&#40;&#41;</code>, passing the object returned by <code>reg2bus&#40;&#41;</code> function. </p> </blockquote> <h3 id=bus2reg ><a href="#bus2reg" class=header-anchor >bus2reg</a></h3> <p>It&#39;s the opposite idea of the <code>reg2bus&#40;&#41;</code>. This function will convert a <strong>Interface transaction</strong> into a <strong>RAL transaction</strong>. Let&#39;s code:</p> <pre><code class="verilog hljs"><span class=hljs-keyword >function</span> <span class=hljs-keyword >void</span> bus2reg(uvm_sequence_item bus_item, <span class=hljs-keyword >ref</span> uvm_reg_bus_op rw);
	cthulhu_transaction tx;
	
	<span class=hljs-keyword >assert</span>( <span class=hljs-built_in >$cast</span>(tx, bus_item) )
	<span class=hljs-keyword >else</span> `uvm_fatal(<span class=hljs-string >&quot;&quot;</span>, <span class=hljs-string >&quot;A bad thing has just happened in my_adapter&quot;</span>)

	rw<span class=hljs-variable >.kind</span> = tx<span class=hljs-variable >.write_en</span> ? UVM_WRITE : UVM_READ;
	rw<span class=hljs-variable >.addr</span> = tx<span class=hljs-variable >.addr</span>;
	rw<span class=hljs-variable >.data</span> = tx<span class=hljs-variable >.data_r</span>;
	
	rw<span class=hljs-variable >.status</span> = UVM_IS_OK;
<span class=hljs-keyword >endfunction</span> : bus2reg</code></pre> <p>So, the rest of class is similar to every component of UVM. The complete code is shown below:</p> <pre><code class="verilog hljs"><span class=hljs-keyword >class</span> cthulhu_adapter <span class=hljs-keyword >extends</span> uvm_reg_adapter;
	`uvm_object_utils (cthulhu_adapter)

	<span class=hljs-keyword >function</span> <span class=hljs-keyword >new</span>(<span class=hljs-keyword >string</span> name = <span class=hljs-string >&quot;cthulhu_adapter&quot;</span>);
		<span class=hljs-keyword >super</span><span class=hljs-variable >.new</span>(name);
	<span class=hljs-keyword >endfunction</span>

	<span class=hljs-keyword >function</span> uvm_sequence_item reg2bus(<span class=hljs-keyword >const</span> <span class=hljs-keyword >ref</span> uvm_reg_bus_op rw);
		cthulhu_transaction tx;    
		tx = cthulhu_transaction::type_id::create(<span class=hljs-string >&quot;tx&quot;</span>);
		
		tx<span class=hljs-variable >.write_en</span> = (rw<span class=hljs-variable >.kind</span> == UVM_WRITE);
		tx<span class=hljs-variable >.addr</span>  = rw<span class=hljs-variable >.addr</span>;
		<span class=hljs-keyword >if</span> (tx<span class=hljs-variable >.write_en</span>)  tx<span class=hljs-variable >.data_w</span> = rw<span class=hljs-variable >.data</span>;
		<span class=hljs-keyword >if</span> (!tx<span class=hljs-variable >.write_en</span>) tx<span class=hljs-variable >.data_r</span> = rw<span class=hljs-variable >.data</span>;

		<span class=hljs-keyword >return</span> tx;
	<span class=hljs-keyword >endfunction</span> : reg2bus

	<span class=hljs-keyword >function</span> <span class=hljs-keyword >void</span> bus2reg(uvm_sequence_item bus_item, <span class=hljs-keyword >ref</span> uvm_reg_bus_op rw);
		cthulhu_transaction tx;
		
		<span class=hljs-keyword >assert</span>( <span class=hljs-built_in >$cast</span>(tx, bus_item) )
		<span class=hljs-keyword >else</span> `uvm_fatal(<span class=hljs-string >&quot;&quot;</span>, <span class=hljs-string >&quot;A bad thing has just happened in my_adapter&quot;</span>)

		rw<span class=hljs-variable >.kind</span> = tx<span class=hljs-variable >.write_en</span> ? UVM_WRITE : UVM_READ;
		rw<span class=hljs-variable >.addr</span> = tx<span class=hljs-variable >.addr</span>;
		rw<span class=hljs-variable >.data</span> = tx<span class=hljs-variable >.data_r</span>;
		
		rw<span class=hljs-variable >.status</span> = UVM_IS_OK;
	<span class=hljs-keyword >endfunction</span> : bus2reg
<span class=hljs-keyword >endclass</span> : cthulhu_adapter</code></pre> <p>Okay, now our ambient is a little morre colorful:</p> <p><img src="/ral/assets/some_percent_diagram_02.png" alt="UVM environment" /></p> <div class=page-foot > <a href="http://creativecommons.org/licenses/by-sa/4.0/">CC BY-SA 4.0</a> Jo√£o Pedro Melquiades Gomes. Last modified: December 13, 2022. Website built with <a href="https://github.com/tlienart/Franklin.jl">Franklin.jl</a> and the <a href="https://julialang.org">Julia programming language</a>. </div> </div> </div> </div> <script src="/ral/libs/pure/ui.min.js"></script> <script src="/ral/libs/highlight/highlight.min.js"></script> <script>hljs.highlightAll();hljs.configure({tabReplace: ' '});</script>